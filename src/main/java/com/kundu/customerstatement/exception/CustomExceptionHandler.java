package com.kundu.customerstatement.exception;

import javax.servlet.http.HttpServletRequest;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

/**
 * This class is used to handle the exceptions generated by different resources.
 * With this centralized approach, there is a chance to provide a similar
 * behavior for different errors generated from different sources.
 * 
 * @author ukundukan
 *
 */
@ControllerAdvice
public class CustomExceptionHandler extends ResponseEntityExceptionHandler {

	/**
	 * MessageSource will used to access the messages defined in the resource
	 * bundle.
	 */
	private MessageSource messageSource;

	@Autowired
	public CustomExceptionHandler(MessageSource _messageSource) {
		this.messageSource = _messageSource;
	}

	/**
	 * Exception will be logged by using this logger.
	 */
	private static final Logger myLogger = LoggerFactory.getLogger(CustomExceptionHandler.class);

	/**
	 * This method is used to handle all BusinessException types. These exceptions
	 * are logged in WARN level and the error messages are translated to
	 * GenericError type.
	 * 
	 * @param request
	 *            The HttpServletRequest which the exception occurred
	 * @param e
	 *            The BusinessException which generated
	 * @return JSON formatted GenericError with the message provided, by using
	 *         HttpStatus.BAD_REQUEST
	 */
	@ExceptionHandler(value = { BusinessException.class })
	@ResponseBody
	ResponseEntity<GenericError> businessExceptionHandler(HttpServletRequest request, BusinessException e) {
		// BusinessExceptions will be logged in WARN level.
		myLogger.warn(String.format("Business exception occurred. bundleKey: %s , errMsg: %s", e.getErrorBundleKey(), e.getErrorMessage()),
				e.getCause());
		String errMsg = null;
		if (e.getErrorBundleKey() != null) {
			errMsg = messageSource.getMessage(e.getErrorBundleKey(), null, request.getLocale());
		} else {
			errMsg = e.getErrorMessage();
		}
		return new ResponseEntity<GenericError>(new GenericError(errMsg), HttpStatus.BAD_REQUEST);
	}

	/**
	 * This method is used to handle all SystemException types. These exceptions are
	 * logged in ERROR level and the error messages are translated to GenericError
	 * type.
	 * 
	 * @param request
	 *            The HttpServletRequest which the exception occurred
	 * @param e
	 *            The SystemException which generated
	 * @return JSON formatted GenericError with the message provided, by using
	 *         HttpStatus.BAD_REQUEST
	 */
	@ExceptionHandler(value = { SystemException.class })
	@ResponseBody
	ResponseEntity<GenericError> systemExceptionHandler(HttpServletRequest request, SystemException e) {
		// SystemExceptions will be logged in ERROR level.
		myLogger.error(String.format("System exception occurred. bundleKey: %s , errMsg: %s", e.getErrorBundleKey(), e.getErrorMessage()),
				e.getCause());
		String errMsg = null;
		if (e.getErrorBundleKey() != null) {
			errMsg = messageSource.getMessage(e.getErrorBundleKey(), null, request.getLocale());
		} else {
			errMsg = e.getErrorMessage();
		}
		return new ResponseEntity<GenericError>(new GenericError(errMsg), HttpStatus.BAD_REQUEST);
	}

	/**
	 * This method is used to handle all exception types other than
	 * BusinessException and SystemException. These exceptions are logged in ERROR
	 * level and a general error message created with the type GenericError.
	 * 
	 * @param request
	 *            The HttpServletRequest which the exception occurred
	 * @param e
	 *            The Throwable which generated
	 * @return JSON formatted GenericError with a standard message, by using
	 *         HttpStatus.INTERNAL_SERVER_ERROR
	 */
	@ExceptionHandler(value = { Throwable.class })
	@ResponseBody
	ResponseEntity<GenericError> defaultErrorHandler(HttpServletRequest request, Exception e) {
		myLogger.error("There is an unhandled error: ", e);
		return new ResponseEntity<GenericError>(new GenericError(messageSource.getMessage("error.unhandled", null, request.getLocale())),
				HttpStatus.INTERNAL_SERVER_ERROR);
	}
}